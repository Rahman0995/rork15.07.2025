// Утилиты для аутентификации и авторизации
// В реальном приложении здесь будет работа с JWT токенами, bcrypt для хеширования паролей и т.д.

import { mockUsers } from '@/constants/mockData';\nimport type { User, UserRole } from '@/types';\n\n// Mock функции для демонстрации\nexport function hashPassword(password: string): string {\n  // В реальном приложении используйте bcrypt\n  return `hashed_${password}`;\n}\n\nexport function verifyPassword(password: string, hashedPassword: string): boolean {\n  // В реальном приложении используйте bcrypt.compare\n  return hashedPassword === `hashed_${password}`;\n}\n\nexport function generateToken(user: User): string {\n  // В реальном приложении используйте jsonwebtoken\n  return `mock_token_${user.id}_${Date.now()}`;\n}\n\nexport function verifyToken(token: string): { userId: string; valid: boolean } {\n  // В реальном приложении используйте jsonwebtoken.verify\n  if (!token.startsWith('mock_token_')) {\n    return { userId: '', valid: false };\n  }\n  \n  const parts = token.split('_');\n  if (parts.length < 3) {\n    return { userId: '', valid: false };\n  }\n  \n  const userId = parts[2];\n  const timestamp = parseInt(parts[3]);\n  const now = Date.now();\n  \n  // Токен действителен 24 часа\n  const isExpired = now - timestamp > 24 * 60 * 60 * 1000;\n  \n  return {\n    userId,\n    valid: !isExpired && mockUsers.some(u => u.id === userId),\n  };\n}\n\nexport function refreshToken(oldToken: string): string | null {\n  const { userId, valid } = verifyToken(oldToken);\n  \n  if (!valid) {\n    return null;\n  }\n  \n  const user = mockUsers.find(u => u.id === userId);\n  if (!user) {\n    return null;\n  }\n  \n  return generateToken(user);\n}\n\n// Функции для проверки прав доступа\nexport function hasPermission(userRole: UserRole, requiredRole: UserRole): boolean {\n  const roleHierarchy: Record<UserRole, number> = {\n    soldier: 1,\n    officer: 2,\n    company_commander: 3,\n    battalion_commander: 4,\n    admin: 5,\n  };\n  \n  return roleHierarchy[userRole] >= roleHierarchy[requiredRole];\n}\n\nexport function canAccessReport(user: User, reportAuthorId: string, reportUnit?: string): boolean {\n  // Автор может всегда получить доступ к своему отчету\n  if (user.id === reportAuthorId) {\n    return true;\n  }\n  \n  // Администратор может получить доступ ко всем отчетам\n  if (user.role === 'admin') {\n    return true;\n  }\n  \n  // Командир батальона может получить доступ ко всем отчетам своего батальона\n  if (user.role === 'battalion_commander' && reportUnit?.includes(user.unit)) {\n    return true;\n  }\n  \n  // Командир роты может получить доступ к отчетам своей роты\n  if (user.role === 'company_commander' && reportUnit === user.unit) {\n    return true;\n  }\n  \n  return false;\n}\n\nexport function canAccessTask(user: User, taskAssignedTo: string, taskCreatedBy: string): boolean {\n  // Исполнитель и создатель могут получить доступ к задаче\n  if (user.id === taskAssignedTo || user.id === taskCreatedBy) {\n    return true;\n  }\n  \n  // Администратор может получить доступ ко всем задачам\n  if (user.role === 'admin') {\n    return true;\n  }\n  \n  // Командиры могут получить доступ к задачам своих подчиненных\n  if (user.role === 'battalion_commander' || user.role === 'company_commander') {\n    const assignedUser = mockUsers.find(u => u.id === taskAssignedTo);\n    if (assignedUser && assignedUser.unit.includes(user.unit)) {\n      return true;\n    }\n  }\n  \n  return false;\n}\n\nexport function canModifyUser(currentUser: User, targetUserId: string): boolean {\n  // Пользователь может изменять свои данные\n  if (currentUser.id === targetUserId) {\n    return true;\n  }\n  \n  // Администратор может изменять данные всех пользователей\n  if (currentUser.role === 'admin') {\n    return true;\n  }\n  \n  const targetUser = mockUsers.find(u => u.id === targetUserId);\n  if (!targetUser) {\n    return false;\n  }\n  \n  // Командир батальона может изменять данные подчиненных\n  if (currentUser.role === 'battalion_commander' && \n      targetUser.unit.includes(currentUser.unit) &&\n      hasPermission(currentUser.role, targetUser.role)) {\n    return true;\n  }\n  \n  // Командир роты может изменять данные подчиненных своей роты\n  if (currentUser.role === 'company_commander' && \n      targetUser.unit === currentUser.unit &&\n      hasPermission(currentUser.role, targetUser.role)) {\n    return true;\n  }\n  \n  return false;\n}\n\n// Утилиты для сессий\nexport interface Session {\n  userId: string;\n  token: string;\n  createdAt: string;\n  expiresAt: string;\n  ipAddress?: string;\n  userAgent?: string;\n}\n\nconst activeSessions = new Map<string, Session>();\n\nexport function createSession(user: User, ipAddress?: string, userAgent?: string): Session {\n  const token = generateToken(user);\n  const session: Session = {\n    userId: user.id,\n    token,\n    createdAt: new Date().toISOString(),\n    expiresAt: new Date(Date.now() + 24 * 60 * 60 * 1000).toISOString(),\n    ipAddress,\n    userAgent,\n  };\n  \n  activeSessions.set(token, session);\n  return session;\n}\n\nexport function getSession(token: string): Session | null {\n  return activeSessions.get(token) || null;\n}\n\nexport function invalidateSession(token: string): boolean {\n  return activeSessions.delete(token);\n}\n\nexport function invalidateAllUserSessions(userId: string): number {\n  let count = 0;\n  for (const [token, session] of activeSessions.entries()) {\n    if (session.userId === userId) {\n      activeSessions.delete(token);\n      count++;\n    }\n  }\n  return count;\n}\n\nexport function cleanupExpiredSessions(): number {\n  const now = new Date();\n  let count = 0;\n  \n  for (const [token, session] of activeSessions.entries()) {\n    if (new Date(session.expiresAt) < now) {\n      activeSessions.delete(token);\n      count++;\n    }\n  }\n  \n  return count;\n}\n\n// Запускаем очистку просроченных сессий каждый час\nsetInterval(cleanupExpiredSessions, 60 * 60 * 1000);